"""This module defines the DISCOSClient class along with
its auxiliary classes, constant and functions."""
from __future__ import annotations
import re
import zmq
import json
from typing import Any, Union
from random import SystemRandom
from types import SimpleNamespace
from threading import Thread

DEFAULT_ADDRESS = '127.0.0.1'
DEFAULT_PORT = 16000
DEFAULT_TOPICS = [
    'mount',
    'antenna',
]


def _get_dict(obj: Any) -> dict:
    """Returns the inner '__dict__' property of a given object.

    :param obj: object of Any type
    :type obj: Any
    :return: the obj inner __dict__
    :rtype: dict
    """
    return obj.__dict__

def _format(obj: Any, format_spec: str) -> str:
    """Formats the given object representation string
    using the given format specifier.

    :param obj: object of Any type
    :type obj: Any
    :return: the formatted representation of obj
    :rtype: str
    """
    repr_str = repr(obj)
    match = re.match(
        r'([<>=^])?(\d+)?(\.\d+)?([bcdeEfFgGnosxX%])?',
        format_spec
    )
    if not match:
        return repr_str
    align = match.group(1) or ''
    width = match.group(2) or ''
    precision = match.group(3) or ''
    type_spec = match.group(4) or ''
    float_format_spec = f'{precision or ""}{type_spec or ""}'
    try:
        repr_str = f'{float(repr_str.split()[-1]):{float_format_spec}}'
    except ValueError:
        pass
    if align:
        repr_str = f'{repr_str:{align}{width}}'
    elif width:
        repr_str = f'{repr_str:{width}}'
    return repr_str


class JsonNamespace(SimpleNamespace):
    """Namespace object. It is generated by the json.loads() method
    by passing this class as object_hook argument. The properties
    contained in the parsed json string are then set as attributes
    in this namespace, meaning they can be accessed as properties
    using the dot '.' notation instead of the access operator '[]'.
    """
    __format__ = _format

    def __repr__(self) -> str:
        """Custom representation method. It returns a json formatted
        representation with new lines and indentation.
        If the namespace is empty returns 'None' as a str instead.

        :return: the object str representation
        :rtype: str
        """
        if not self.__dict__:
            return str(None)
        return json.dumps(self, default=_get_dict, indent=2)

    def __getattr__(self, name: str) -> Any:
        """Custom implementation. It returns the desired attribute or
        an empty object of JsonNamespace type.

        :param name: the desired attribute name
        :type name: str
        :return: the desired attribute
        :rtype: Any
        """
        return getattr(super(), name, JsonNamespace())

    @staticmethod
    def update_nested_namespace(
        base_ns: JsonNamespace,
        other_ns: JsonNamespace
    ) -> None:
        for k, v in other_ns.__dict__.items():
            if hasattr(base_ns, k):
                base_attr = getattr(base_ns, k)
                if (isinstance(base_attr, JsonNamespace)
                        and isinstance(v, JsonNamespace)):
                    JsonNamespace.update_nested_namespace(base_attr, v)
                    continue
            setattr(base_ns, k, v)


class DISCOSClient:
    __format__ = _format

    def __init__(
        self,
        topics: Union[str, list[str]] = DEFAULT_TOPICS,
        address: str = DEFAULT_ADDRESS,
        port: int = DEFAULT_PORT,
        auto_update: bool = False
    ) -> None:
        if isinstance(topics, str):
            topics = list(topics)
        if not isinstance(topics, list) or not topics:
            raise ValueError(
                "'topics' should be a string or a non-empty list of strings!"
            )
        invalid = [t for t in topics if t not in DEFAULT_TOPICS]
        if invalid:
            if len(invalid) > 1:
                p = ('s', 'are')
                invalid = \
                    f"""s '{"', '".join(invalid[:-1])}'""" \
                    f""" and '{invalid[-1]}' are"""
            else:
                invalid = f""" '{invalid[0]}' is"""
            raise ValueError(
                f"""Topic{invalid} not known!"""
            )
        self.__topics = topics
        self.__context = zmq.Context()
        self.__socket = self.__context.socket(zmq.SUB)
        self.__socket.setsockopt(zmq.RCVTIMEO, 10)
        self.__randid = str(SystemRandom().randint(0, 100)).zfill(3)
        self.__socket.connect(f'tcp://{address}:{port}')
        self.__initialized = False
        for topic in topics:
            self.__socket.subscribe(f'{self.__randid}_{topic}')
            try:
                self.wait_for_update()
            except zmq.Again:
                pass
            self.__socket.unsubscribe(f'{self.__randid}_{topic}')
        self.__initialized = True
        self.__socket.setsockopt(zmq.RCVTIMEO, -1)
        for topic in topics:
            self.__socket.subscribe(topic)
        self.__t__ = None
        if auto_update:
            self.__update_thread = Thread(target=self.__auto_update)
            self.__update_thread.daemon = True
            self.__update_thread.start()

    def __auto_update(self) -> None:
        while True:
            self.wait_for_update()

    def wait_for_update(self, topic: str = None) -> JsonNamespace:
        if topic and topic not in self.__topics:
            raise KeyError(f"The client is not subscribed to '{topic}'")
        while True:
            _message = self.__socket.recv_string()
            _topic, _payload = _message.split()
            if not self.__initialized:
                _topic = _topic.replace(f'{self.__randid}_', '')
            _payload = json.loads(
                _payload,
                object_hook=lambda item: JsonNamespace(**item)
            )
            if _topic not in self.__dict__:
                self.__dict__[_topic] = _payload
            else:
                JsonNamespace.update_nested_namespace(
                    self.__dict__[_topic],
                    _payload
                )
            if topic is None or topic == _topic:
                return _payload

    def __getattr__(self, name: str) -> Any:
        return self.__dict__.get(name, JsonNamespace())

    def __repr__(self) -> str:
        d = dict(filter(
            lambda item: item[0] in self.__topics, self.__dict__.items()
        ))
        if not d:
            return str(None)
        return json.dumps(d, default=_get_dict, indent=2)
